## Дублирующиеся роуты и «мертвый» код

### 1. Дублирующиеся и конфликтующие роуты

#### 1.1. Дублирование API и страниц оборудования

В `backend/routers/well_equipment_integration.py` реализован расширенный интеграционный слой, но при этом он **дублирует** значительную часть API и HTML‑роутов, уже реализованных в `backend/routers/equipment_management.py`:

- **HTML‑страницы:**
  - `/equipment/add`:
    - `equipment_management.py::equipment_add_page`
    - `well_equipment_integration.py::equipment_add_page` (аналогичный маршрут)
  - `/equipment`:
    - `equipment_management.py::equipment_list_page`
    - `well_equipment_integration.py::equipment_list_page`
  - `/equipment/{equipment_id}` vs `/equipment/view/{equipment_id}`:
    - `equipment_management.py` использует `/equipment/view/{id}`;
    - `well_equipment_integration.py` добавляет `/equipment/{id}` с похожей логикой.

- **API по оборудованию:**
  - `/api/equipment/create`
  - `/api/equipment/{equipment_id}/move`
  - `/api/equipment/{equipment_id}/update_status`
  - `/api/equipment/{equipment_id}/add_maintenance`
  - `/api/equipment/{equipment_id}` (DELETE)

Все эти маршруты определены как в `equipment_management.py`, так и в `well_equipment_integration.py`. Это создаёт:

- риск расхождения логики (фиксы в одном модуле не попадают во второй);
- неочевидность для разработчика: какой роутер «правильный» и где менять код;
- сложности при чтении карт прав доступа и анализе логики.

**Рекомендация**: оставить единственный источник правды для CRUD по оборудованию (например, `equipment_management.py`) и в `well_equipment_integration.py` использовать его как сервисный слой (через функции/репозитории), либо вообще удалить дублирующие маршруты и оставить только специфичные интеграционные (`/api/wells/{well_id}/equipment`, `/api/equipment/available` и т.п.).

#### 1.2. Дублирующиеся определения одного и того же пути в одном файле

В `backend/routers/well_equipment_integration.py` обнаружены **двойные объявления одного и того же маршрута**:

- `/api/wells/{well_id}/install-equipment` объявлен дважды (две разные функции).  
  FastAPI примет последнее определение, а первое фактически будет «переписано», что:
  - сбивает с толку;
  - может скрыть старую/несогласованную логику.

**Рекомендация**: оставить только один, актуальный обработчик для каждого пути и удалить устаревшую версию.

#### 1.3. Пересекающиеся «админские» роуты реагентов

- Базовый модуль учёта реагентов реализован в `backend/app.py`:
  - `/admin/reagents`
  - `/admin/reagents/add`
  - `/admin/reagents/inventory`
  - `/admin/reagents/inventory/add`
  - `/admin/reagents/import` (GET/POST)
- Параллельно существует JSON‑API в `backend/api/reagents.py`:
  - `/api/reagents`
  - `/api/reagents/balance`

Логика учёта и балансов частично пересекается между `app.py` (ручной расчёт/агрегации) и `ReagentBalanceService` + `repositories/reagents_service.py`.  
Функции `_resolve_reagent_from_form`, `_get_or_create_catalog_item` и обработчик `/admin/reagents/add` содержат сложный, монолитный код, который дублирует логику каталога/баланса, уже вынесенную в сервисы.

**Рекомендация**:

- вынести обработку реагентов из `app.py` в отдельный роутер (`backend/routers/reagents_admin.py`) с использованием `ReagentBalanceService` и репозитория;
- унифицировать бизнес‑логику (одна точка правды для поиска/создания каталожных позиций и пересчёта остатков).

---

### 2. Потенциально «мертвые» или малоиспользуемые эндпойнты

Опираясь на поиск по проекту (строки использования путей в шаблонах/JS) можно выделить набор маршрутов, которые:

- либо **не имеют ссылок** из HTML/JS (предположительно используются только вручную через URL или вовсе забыты),
- либо продублированы и, вероятно, являются старой версией.

#### 2.1. Старые/встроенные в сервисы роуты

- `backend/services/well_service.py` содержит `@app.get("/well/{well_identifier}")` (поиск в `grep`), при том что актуальный маршрут для страницы скважины реализован в `backend/app.py`.  
  Нет следов `include_router` или явной регистрации этого `app` из сервисного модуля → **высокая вероятность, что эта версия роутера не используется**.

#### 2.2. Диагностические эндпойнты

Эндпойнты, явно отмеченные как диагностические/тестовые:

- `backend/routers/equipment_admin.py`:
  - `/admin/equipment/test-move`
  - `/admin/equipment/test-status`
  Используются из шаблона `equipment_admin.html` (форма/кнопки для тестирования). Они не мертвы, но являются **диагностическими** и потенциально могут быть отключены в боевой среде либо защищены дополнительными правами.

- `backend/app.py::debug_well_equipment` – `/debug/well/{well_id}/equipment`  
  В шаблонах и JS прямых ссылок нет; возможно, используется только вручную для отладки. Кандидат на:
  - либо более явную привязку (кнопка «Debug» на админских страницах),
  - либо удаление/скрытие за флагом окружения.

#### 2.3. API без внутренних ссылок

Часть JSON‑API не имеет прямых ссылок в шаблонах, но при этом логична как внешний API:

- `/api/equipment/add` (`equipment_documents.py`) – REST‑создание оборудования по JSON;  
  в шаблонах нет форм/JS, которые вызывают этот путь. Это может быть:
  - либо задел под внешнюю интеграцию (тогда стоит задокументировать),
  - либо забытый/неиспользуемый эндпойнт.

- `/api/reagents` (GET/POST), `/api/reagents/balance` – используются в основном как API‑слой; прямых ссылок из HTML немного. Если они не документированы/не используются внешними системами, стоит:
  - либо явно зафиксировать их как публичный API,
  - либо ограничить до внутренних вызовов и/или задепрекейтить.

---

### 3. Бизнес‑логика в `app.py` и `routers`

#### 3.1. `backend/app.py` как монолит доменной логики

В `app.py` сосредоточено сразу несколько крупных доменных областей:

- аутентификация и управление пользователями/ролями;
- подробный учёт реагентов и инвентаризации;
- полное управление страницей скважины (статусы, заметки, оборудование, каналы, координаты);
- API по событиям (`/api/well/{id}/events*`).

Многие обработчики содержат:

- непосредственные SQLAlchemy‑запросы (join/aggregate) прямо в роутере;
- парсинг и валидацию форм (`request.form()`), обработку дат/чисел;
- логику изменения состояний (`WellStatus`, `WellEquipment`, `WellNote` и т.п.).

Это нарушает разделение слоёв:

- сложно повторно использовать логику вне веб‑уровня;
- трудно покрывать тестами (много логики внутри async/def‑эндпойнтов);
- растёт размер и когнитивная сложность `app.py` (3000+ строк).

**Рекомендация (постепенный рефакторинг):**

- вынести доменные операции в сервисные модули (`services/well_service.py`, `services/reagent_balance_service.py`, отдельные `equipment_service.py`, `user_admin_service.py` и т.п.);
- в роутерах оставить только:
  - разбор входящих данных (Form/Query/Body),
  - вызов соответствующего сервиса,
  - оформление ответа (HTML/JSON/Redirect).

#### 3.2. Сложная логика в роутерах документов

Модули:

- `documents_pages.py`
- `documents_well_handover.py`
- `equipment_documents.py`

содержат в маршрутах:

- нетривиальные алгоритмы подбора событий/давлений по скважинам;
- генерацию номеров документов;
- подготовку сложной `meta`‑структуры для LaTeX;
- непосредственный вызов `xelatex` с обработкой логов и файловой системой.

Это **ядро бизнес‑логики системы документов**, которое сейчас живёт прямо в HTTP‑слое.

**Рекомендация**:

- выделить `documents/services/...` для:
  - генерации номеров;
  - вычисления давлений и диапазонов;
  - формирования `meta` для конкретных типов документов;
  - вызова LaTeX‑компиляции.
- в роутерах оставить только тонкий веб‑слой.

---

### 4. Выводы для рефакторинга

- **Устранить дублирующиеся маршруты**:
  - привести `well_equipment_integration.py` к роли «надстройки» над единственным модулем управления оборудованием;
  - убрать двойные определения одного и того же пути внутри файла.
- **Очистить «мертвый» и диагностический код**:
  - явным образом маркировать диагностические эндпойнты (через настройки/feature‑флаги или админ‑роль);
  - удалить или задепрекейтить неиспользуемые пути (`/debug/...`, старые роуты в сервисах).
- **Разделить слои**:
  - постепенно вытаскивать бизнес‑логику из `app.py` и роутеров в сервисы/репозитории;
  - оставить в роутерах только HTTP‑обвязку.

Эти шаги снизят связанность, уменьшат риск регрессий при изменении логики и упростят поддержку проекта.

